<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serial Sync Control with MQTT</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            background: #fafafa;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, textarea, button {
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-danger:hover {
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn-success:hover {
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }

        .btn-secondary:hover {
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.3);
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 600;
        }

        .status.connected {
            background: #d5f4e6;
            color: #27ae60;
            border: 2px solid #27ae60;
        }

        .status.disconnected {
            background: #fadbd8;
            color: #e74c3c;
            border: 2px solid #e74c3c;
        }

        .status.syncing {
            background: #fef9e7;
            color: #f39c12;
            border: 2px solid #f39c12;
        }

        .device-list {
            display: grid;
            gap: 15px;
        }

        .device-item {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .device-item.device-disconnected {
            background: #fdf2f2;
            border-color: #f5c6cb;
            opacity: 0.8;
        }

        .device-item.device-disconnected .device-name {
            color: #721c24;
        }

        .device-info {
            flex: 1;
        }

        .device-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .device-status {
            font-size: 0.9em;
            opacity: 0.7;
        }

        .log-container {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-timestamp {
            color: #3498db;
            margin-right: 10px;
        }

        .sync-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .sync-stat {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #ecf0f1;
        }

        .sync-stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }

        .sync-stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .main-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîó Serial Sync Control with MQTT</h1>
            <p>Synchronized command execution across multiple serial devices with MQTT messaging</p>
        </div>

        <div class="main-content">
            <!-- Connection Section -->
            <div class="section">
                <h2>üîå Device Connection</h2>
                <div class="controls">
                    <div class="control-group">
                        <button id="connectBtn" onclick="connectSerial()">Connect Serial Device</button>
                    </div>
                    <div class="control-group">
                        <button id="disconnectBtn" onclick="disconnectSerial()" disabled>Disconnect All</button>
                    </div>
                </div>
                <div id="connectionStatus" class="status disconnected">
                    No devices connected
                </div>
            </div>

            <!-- MQTT Connection Section -->
            <div class="section">
                <h2>üì° MQTT Connection</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="mqttBroker">MQTT Broker URL:</label>
                        <input type="text" id="mqttBroker" value="wss://01a0e2bb7f5d48d38c0ce23a40d1d506.s2.eu.hivemq.cloud:8884/mqtt" placeholder="wss://your-cluster.hivemq.cloud:8884/mqtt">
                    </div>
                    <div class="control-group">
                        <label for="mqttClientId">Client ID:</label>
                        <input type="text" id="mqttClientId" placeholder="Auto-generated" readonly>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label for="mqttUsername">Username (required for HiveMQ Cloud):</label>
                        <input type="text" id="mqttUsername" placeholder="Enter your HiveMQ Cloud username">
                    </div>
                    <div class="control-group">
                        <label for="mqttPassword">Password (required for HiveMQ Cloud):</label>
                        <input type="password" id="mqttPassword" placeholder="Enter your HiveMQ Cloud password">
                    </div>
                </div>
                <div class="controls">
                    <button id="connectMqttBtn" onclick="connectMqtt()">Connect to MQTT</button>
                    <button id="disconnectMqttBtn" onclick="disconnectMqtt()" disabled>Disconnect MQTT</button>
                </div>
                <div id="mqttConnectionStatus" class="status disconnected">
                    MQTT not connected
                </div>
            </div>

            <!-- MQTT Subscription Section -->
            <div class="section">
                <h2>üì¨ MQTT Subscriptions</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="mqttTopic">Topic to Subscribe:</label>
                        <input type="text" id="mqttTopic" value="esp32/commands" placeholder="esp32/commands">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="autoSubscribeRhythm" checked> Auto-subscribe to "trigger_rhythm" topic
                        </label>
                        <small style="color: #7f8c8d; display: block; margin-top: 5px;">
                            Automatically subscribes to rhythm control topic for BPM and beat division changes
                        </small>
                    </div>
                    <div class="control-group">
                        <label for="mqttQos">QoS Level:</label>
                        <select id="mqttQos">
                            <option value="0">0 - At most once</option>
                            <option value="1" selected>1 - At least once</option>
                            <option value="2">2 - Exactly once</option>
                        </select>
                    </div>
                </div>
                <div class="controls">
                    <button id="subscribeMqttBtn" onclick="subscribeMqtt()" disabled>Subscribe to Topic</button>
                    <button id="unsubscribeMqttBtn" onclick="unsubscribeMqtt()" disabled>Unsubscribe</button>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label for="publishTopic">Publish Topic:</label>
                        <input type="text" id="publishTopic" value="esp32/status" placeholder="esp32/status">
                    </div>
                    <div class="control-group">
                        <label for="publishMessage">Message to Publish:</label>
                        <textarea id="publishMessage" rows="2" placeholder="Enter message to publish..."></textarea>
                    </div>
                </div>
                <div class="controls">
                    <button id="publishMqttBtn" onclick="publishMqtt()" disabled>Publish Message</button>
                </div>
                <div id="mqttSubscriptionStatus" class="status disconnected">
                    No active subscriptions
                </div>
            </div>

            <!-- MQTT Messages -->
            <div class="section">
                <h2>üì® MQTT Messages</h2>
                <div class="controls">
                    <button onclick="clearMqttMessages()">Clear Messages</button>
                    <button onclick="saveMqttLog()">üíæ Save MQTT Log</button>
                    <label>
                        <input type="checkbox" id="autoExecuteMqtt"> Auto-execute received commands on serial devices
                    </label>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #3498db;">
                    <h4 style="margin: 0 0 10px 0; color: #2c3e50;">üéµ Rhythm Control Topic: "trigger_rhythm"</h4>
                    <p style="margin: 0 0 10px 0; color: #7f8c8d; font-size: 14px;">
                        Send messages to control BPM and beat division remotely:
                    </p>
                    <div style="font-family: 'Courier New', monospace; font-size: 13px; color: #2c3e50;">
                        <div style="margin-bottom: 5px;"><strong>Simple format:</strong></div>
                        <div style="margin-left: 15px; margin-bottom: 8px;">
                            ‚Ä¢ <code>bpm:120</code> - Set BPM to 120<br>
                            ‚Ä¢ <code>division:8</code> - Set beat division to 1/8 notes<br>
                            ‚Ä¢ <code>bpm:140,division:4</code> - Set both BPM and division
                        </div>
                        <div style="margin-bottom: 5px;"><strong>JSON format:</strong></div>
                        <div style="margin-left: 15px;">
                            ‚Ä¢ <code>{"bpm": 120, "division": 4}</code>
                        </div>
                    </div>
                </div>
                <div id="mqttMessages" class="log-container" style="height: 200px; background: #0d1117; color: #58a6ff;">
                    <div style="color: #7d8590; font-style: italic;">üì° MQTT messages will appear here...</div>
                </div>
            </div>

            <!-- Connected Devices -->
            <div class="section">
                <h2>üì± Connected Devices</h2>
                <div id="deviceList" class="device-list">
                    <p style="text-align: center; color: #7f8c8d; font-style: italic;">No devices connected yet</p>
                </div>
            </div>

            <!-- Synchronization Status -->
            <div class="section">
                <h2>‚è∞ Synchronization Status</h2>
                <div class="sync-info">
                    <div class="sync-stat">
                        <div id="ntpOffset" class="sync-stat-value">--</div>
                        <div class="sync-stat-label">NTP Offset (ms)</div>
                    </div>
                    <div class="sync-stat">
                        <div id="connectedCount" class="sync-stat-value">0</div>
                        <div class="sync-stat-label">Connected Devices</div>
                    </div>
                    <div class="sync-stat">
                        <div id="lastSync" class="sync-stat-value">--</div>
                        <div class="sync-stat-label">Last Sync (NTP)</div>
                    </div>
                    <div class="sync-stat">
                        <div id="currentPhantomTime" class="sync-stat-value">--</div>
                        <div class="sync-stat-label">Current Phantom Time</div>
                    </div>
                </div>
                <button id="syncBtn" onclick="syncTime()" class="btn-success">üîÑ Sync Time with NTP</button>
            </div>

            <!-- Command Control -->
            <div class="section">
                <h2>‚ö° Command Control</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="commandInput">Command to Send:</label>
                        <textarea id="commandInput" rows="3" placeholder="Enter command to send to all devices..."></textarea>
                    </div>
                    <div class="control-group">
                        <label for="schedulingMode">Scheduling Mode:</label>
                        <select id="schedulingMode" onchange="updateSchedulingMode()">
                            <option value="delay">Time Delay</option>
                            <option value="bpm">BPM (Beats Per Minute)</option>
                            <option value="fps">FPS (Frames Per Second)</option>
                        </select>
                    </div>
                </div>
                
                <!-- Time Delay Mode -->
                <div class="controls" id="delayModeControls">
                    <div class="control-group">
                        <label for="delayInput">Execution Delay (seconds):</label>
                        <input type="number" id="delayInput" value="5" min="1" max="3600">
                    </div>
                </div>
                
                <!-- BPM Mode -->
                <div class="controls" id="bpmModeControls" style="display: none;">
                    <div class="control-group">
                        <label for="bpmInput">BPM (Beats Per Minute):</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="bpmInput" value="120" min="30" max="300" step="0.1" style="flex: 1;">
                            <button id="tapTempoBtn" onclick="tapTempo()" class="btn-success" style="padding: 8px 12px; font-size: 14px;">ü•Å Tap Tempo</button>
                        </div>
                        <div id="tapTempoInfo" style="font-size: 12px; color: #7f8c8d; margin-top: 5px; display: none;">
                            Tap the button to the beat. BPM will be calculated from your taps.
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="beatDivision">Beat Division:</label>
                        <select id="beatDivision">
                            <option value="1">Whole Note (1/1)</option>
                            <option value="2">Half Note (1/2)</option>
                            <option value="4" selected>Quarter Note (1/4)</option>
                            <option value="8">Eighth Note (1/8)</option>
                            <option value="16">Sixteenth Note (1/16)</option>
                            <option value="32">Thirty-second Note (1/32)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="beatCount">Number of Beats:</label>
                        <input type="number" id="beatCount" value="4" min="1" max="64">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="bpmLoop"> Loop continuously
                        </label>
                    </div>
                </div>
                
                <!-- FPS Mode -->
                <div class="controls" id="fpsModeControls" style="display: none;">
                    <div class="control-group">
                        <label for="fpsInput">FPS (Frames Per Second):</label>
                        <select id="fpsInput">
                            <option value="23.976">23.976 (Film)</option>
                            <option value="24">24 (Cinema)</option>
                            <option value="25">25 (PAL)</option>
                            <option value="29.97">29.97 (NTSC)</option>
                            <option value="30" selected>30 (Standard)</option>
                            <option value="50">50 (PAL Progressive)</option>
                            <option value="59.94">59.94 (NTSC Progressive)</option>
                            <option value="60">60 (High Frame Rate)</option>
                            <option value="120">120 (Ultra High)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="frameInterval">Frame Interval:</label>
                        <input type="number" id="frameInterval" value="30" min="1" max="3600" placeholder="Execute every N frames">
                    </div>
                    <div class="control-group">
                        <label for="totalFrames">Total Frames:</label>
                        <input type="number" id="totalFrames" value="300" min="1" max="36000" placeholder="Total frames to execute">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="fpsLoop"> Loop continuously
                        </label>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="sendBtn" onclick="scheduleCommand()" disabled class="btn-success">üì§ Schedule Command</button>
                    <button id="cancelBtn" onclick="cancelScheduled()" disabled class="btn-danger">‚ùå Cancel Scheduled</button>
                    <button id="startMetronome" onclick="toggleMetronome()" class="btn-success" style="display: none;">üéµ Start Metronome</button>
                </div>
                
                <!-- Timing Info Display -->
                <div class="sync-info" id="timingInfo" style="display: none;">
                    <div class="sync-stat">
                        <div id="currentTiming" class="sync-stat-value">--</div>
                        <div class="sync-stat-label">Current Timing</div>
                    </div>
                    <div class="sync-stat">
                        <div id="nextExecution" class="sync-stat-value">--</div>
                        <div class="sync-stat-label">Next Execution</div>
                    </div>
                    <div class="sync-stat">
                        <div id="executionCount" class="sync-stat-value">0</div>
                        <div class="sync-stat-label">Executions</div>
                    </div>
                </div>
                
                <div id="commandStatus" class="status disconnected">
                    Ready to send commands
                </div>
            </div>

            <!-- Serial Monitor & Raw Testing -->
            <div class="section">
                <h2>üñ•Ô∏è Serial Monitor & Raw Testing</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="rawInput">Raw Input (test individual characters):</label>
                        <input type="text" id="rawInput" placeholder="Type here to send raw characters..." maxlength="1">
                        <small style="color: #7f8c8d;">Each character will be sent immediately as you type</small>
                    </div>
                    <div class="control-group">
                        <label for="testCommand">Test Command:</label>
                        <input type="text" id="testCommand" placeholder="Enter command to test..." value="1">
                    </div>
                </div>
                <div class="controls">
                    <button onclick="sendRaw()" disabled id="sendRawBtn" class="btn-success">Send Raw (no line ending)</button>
                    <button onclick="sendWithCR()" disabled id="sendCRBtn" class="btn-success">Send + CR (\\r)</button>
                    <button onclick="sendWithLF()" disabled id="sendLFBtn" class="btn-success">Send + LF (\\n)</button>
                    <button onclick="sendWithCRLF()" disabled id="sendCRLFBtn" class="btn-success">Send + CRLF (\\r\\n)</button>
                </div>
                
                <!-- Enhanced Serial Monitor -->
                <div class="controls">
                    <div class="control-group">
                        <label>üì° Serial Data Monitor (Real-time):</label>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                            <button onclick="clearMonitor()">Clear Monitor</button>
                            <button onclick="pauseMonitor()" id="pauseBtn">‚è∏Ô∏è Pause</button>
                            <button onclick="saveMonitorLog()">üíæ Save Log</button>
                            <label style="margin-left: 20px;">
                                <input type="checkbox" id="hexDisplay"> Show as HEX
                            </label>
                            <label>
                                <input type="checkbox" id="autoScroll" checked> Auto-scroll
                            </label>
                            <label>
                                <input type="checkbox" id="showTimestamps" checked> Timestamps
                            </label>
                            <label>
                                <input type="checkbox" id="filterEmpty"> Filter Empty
                            </label>
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;">
                            <label for="baudRateDisplay">Baud Rate:</label>
                            <select id="baudRateDisplay" onchange="updateBaudRate()">
                                <option value="1200">1200</option>
                                <option value="2400">2400</option>
                                <option value="4800">4800</option>
                                <option value="9600">9600</option>
                                <option value="19200">19200</option>
                                <option value="38400">38400</option>
                                <option value="57600">57600</option>
                                <option value="115200" selected>115200</option>
                                <option value="230400">230400</option>
                                <option value="460800">460800</option>
                                <option value="921600">921600</option>
                            </select>
                            <label for="encodingSelect" style="margin-left: 15px;">Encoding:</label>
                            <select id="encodingSelect" onchange="updateEncoding()">
                                <option value="utf-8" selected>UTF-8</option>
                                <option value="ascii">ASCII</option>
                                <option value="latin1">Latin-1</option>
                                <option value="binary">Binary/Raw</option>
                            </select>
                            <button onclick="detectBaudRate()" style="margin-left: 15px; padding: 5px 10px; font-size: 12px;">üîç Auto-detect Baud</button>
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                            <span>üìä Bytes: <span id="byteCount">0</span></span>
                            <span style="margin-left: 10px;">üìà Rate: <span id="dataRate">0 B/s</span></span>
                            <span style="margin-left: 15px;">üéØ Quality: <span id="dataQuality">Unknown</span></span>
                            <span style="margin-left: 15px;">üì° Pattern: <span id="dataPattern">Analyzing...</span></span>
                        </div>
                        <div id="serialMonitor" class="log-container" style="height: 300px; background: #0d1117; color: #58a6ff; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 13px; border: 2px solid #30363d;">
                            <div style="color: #7d8590; font-style: italic;">üîç Monitoring serial data... Connect a device to see output.</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Log -->
            <div class="section">
                <h2>üìã Activity Log</h2>
                <div id="logContainer" class="log-container">
                    <div class="log-entry">
                        <span class="log-timestamp">[System]</span>
                        Serial Sync Control initialized. Ready to connect devices.
                    </div>
                </div>
                <button onclick="clearLog()" style="margin-top: 10px;">Clear Log</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script>
        // Global variables
        let connectedPorts = [];
        let ntpOffset = 0;
        let scheduledCommands = [];
        let syncInterval;
        let bpmInterval;
        let fpsInterval;
        let metronomeInterval;
        let isMetronomeRunning = false;
        let executionCounter = 0;
        let currentSchedulingMode = 'delay';
        let currentBpmLoop = false;
        let currentFpsLoop = false;
        let tapTimes = [];
        let tapTimeoutId = null;
        let connectionHealthInterval;
        let phantomTimeDisplayInterval;
        
        // MQTT variables
        let mqttClient = null;
        let mqttConnected = false;
        let subscribedTopics = [];
        let mqttMessages = [];

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            log('Application started');
            checkSerialSupport();
            startNTPSync();
            startDataRateMonitoring();
            startConnectionHealthMonitoring();
            initializeMqtt();
            startPhantomTimeDisplay();
            
            // Initialize baud rate (ESP32 commonly uses 115200)
            window.selectedBaudRate = 115200;
            document.getElementById('baudRateDisplay').value = '115200';
            
            // Add event listeners for timing updates
            document.getElementById('bpmInput').addEventListener('input', updateBpmTiming);
            document.getElementById('beatDivision').addEventListener('change', updateBpmTiming);
            document.getElementById('fpsInput').addEventListener('change', updateFpsTiming);
            document.getElementById('frameInterval').addEventListener('input', updateFpsTiming);
        });

        // Check if Web Serial API is supported
        function checkSerialSupport() {
            if (!('serial' in navigator)) {
                log('ERROR: Web Serial API not supported. Please use Chrome/Edge browser.', 'error');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('connectionStatus').textContent = 'Web Serial API not supported';
                return false;
            }
            log('Web Serial API supported');
            return true;
        }

        // Connect to a serial device
        async function connectSerial() {
            try {
                log('Requesting serial port...');
                const port = await navigator.serial.requestPort();
                
                // Use selected baud rate or default to 115200 (common for ESP32)
                const baudRate = window.selectedBaudRate || 115200;
                
                log(`Opening serial connection at ${baudRate} baud...`);
                await port.open({
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    bufferSize: 4096,
                    flowControl: 'none'
                });

                const deviceInfo = {
                    port: port,
                    id: `device_${Date.now()}`,
                    name: `ESP32 Device ${connectedPorts.length + 1}`,
                    connected: true,
                    baudRate: baudRate,
                    reader: null
                };

                connectedPorts.push(deviceInfo);

                updateDeviceList();
                updateConnectionStatus();
                log(`Connected to ESP32 device at ${baudRate} baud (${connectedPorts.length} total)`);

                // Set up reader for incoming data
                setupPortReader(port, connectedPorts.length - 1);

            } catch (error) {
                log(`Failed to connect: ${error.message}`, 'error');
                if (error.name === 'NetworkError') {
                    log('Tip: Make sure the device is not already connected in another application', 'warning');
                }
            }
        }

        // Set up reader for a port
        async function setupPortReader(port, index) {
            try {
                const reader = port.readable.getReader();
                let buffer = new Uint8Array(0);
                
                // Store reader reference for cleanup
                if (connectedPorts[index]) {
                    connectedPorts[index].reader = reader;
                }

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        // Port was closed/disconnected
                        log(`Device ${index + 1} disconnected (reader done)`, 'warning');
                        handleDeviceDisconnect(index);
                        break;
                    }
                    
                    // Concatenate new data to buffer
                    const newBuffer = new Uint8Array(buffer.length + value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(value, buffer.length);
                    buffer = newBuffer;
                    
                    // Display raw data in serial monitor immediately
                    displayInMonitor(value, `RX Dev${index + 1}`);
                    
                    // Try to decode and process text data
                    try {
                        const decoder = new TextDecoder('utf-8', { fatal: false, ignoreBOM: true });
                        const text = decoder.decode(buffer, { stream: false });
                        
                        // Process complete lines (split on both \n and \r\n)
                        const lines = text.split(/\r?\n/);
                        
                        // Keep the last incomplete line in buffer
                        if (lines.length > 1) {
                            const lastLine = lines.pop();
                            
                            // Process complete lines
                            for (const line of lines) {
                                const cleanLine = line.trim();
                                if (cleanLine.length > 0 || !document.getElementById('filterEmpty')?.checked) {
                                    log(`Device ${index + 1} received: ${cleanLine}`);
                                }
                            }
                            
                            // Update buffer with remaining incomplete line
                            if (lastLine) {
                                const encoder = new TextEncoder();
                                buffer = encoder.encode(lastLine);
                            } else {
                                buffer = new Uint8Array(0);
                            }
                        }
                    } catch (decodeError) {
                        // If decoding fails, keep accumulating bytes
                        // This handles cases where UTF-8 sequences are split across reads
                    }
                    
                    // Prevent buffer from growing too large
                    if (buffer.length > 4096) {
                        // Force process whatever we have and reset
                        try {
                            const decoder = new TextDecoder('utf-8', { fatal: false });
                            const text = decoder.decode(buffer);
                            if (text.trim().length > 0) {
                                log(`Device ${index + 1} received (forced): ${text.trim()}`);
                            }
                        } catch (e) {
                            log(`Device ${index + 1} received binary data (${buffer.length} bytes)`);
                        }
                        buffer = new Uint8Array(0);
                    }
                }
                
                // Process any remaining buffer content
                if (buffer.length > 0) {
                    try {
                        const decoder = new TextDecoder('utf-8', { fatal: false });
                        const text = decoder.decode(buffer);
                        if (text.trim().length > 0) {
                            log(`Device ${index + 1} received (final): ${text.trim()}`);
                        }
                    } catch (e) {
                        log(`Device ${index + 1} final binary data (${buffer.length} bytes)`);
                    }
                }
            } catch (error) {
                log(`Reader error for device ${index + 1}: ${error.message}`, 'error');
                
                // Handle different types of disconnection errors
                if (error.name === 'NetworkError' ||
                    error.name === 'NotReadableError' ||
                    error.message.includes('device has been lost') ||
                    error.message.includes('disconnected') ||
                    error.message.includes('not open') ||
                    error.message.includes('The device has been lost') ||
                    error.message.includes('Failed to execute') ||
                    port.readable === null) {
                    log(`Device ${index + 1} disconnected unexpectedly`, 'warning');
                    handleDeviceDisconnect(index);
                }
                
                // Try to release the reader
                try {
                    if (reader) {
                        reader.releaseLock();
                    }
                } catch (releaseError) {
                    // Ignore release errors
                }
            }
        }

        // Handle device disconnection
        function handleDeviceDisconnect(index) {
            if (index >= 0 && index < connectedPorts.length && connectedPorts[index]) {
                const deviceName = connectedPorts[index].name || `Device ${index + 1}`;
                
                // Mark device as disconnected
                connectedPorts[index].connected = false;
                
                // Remove from array after a short delay to allow for reconnection attempts
                setTimeout(() => {
                    if (index < connectedPorts.length && !connectedPorts[index].connected) {
                        connectedPorts.splice(index, 1);
                        updateDeviceList();
                        updateConnectionStatus();
                        log(`${deviceName} removed from device list`);
                        
                        // Show user notification
                        showDisconnectNotification(deviceName);
                    }
                }, 2000); // 2 second delay
                
                // Immediate UI update to show disconnected status
                updateDeviceList();
                updateConnectionStatus();
            }
        }

        // Show disconnect notification to user
        function showDisconnectNotification(deviceName) {
            // Create a temporary notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            notification.innerHTML = `üîå ${deviceName} disconnected`;
            
            // Add slide-in animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                    if (style.parentNode) {
                        document.head.removeChild(style);
                    }
                }, 300);
            }, 5000);
        }

        // Disconnect all serial devices
        async function disconnectSerial() {
            try {
                for (let i = 0; i < connectedPorts.length; i++) {
                    if (connectedPorts[i].port && connectedPorts[i].connected) {
                        await connectedPorts[i].port.close();
                        log(`Disconnected device ${i + 1}`);
                    }
                }
                connectedPorts = [];
                updateDeviceList();
                updateConnectionStatus();
                log('All devices disconnected');
            } catch (error) {
                log(`Disconnect error: ${error.message}`, 'error');
            }
        }

        // Update device list display
        function updateDeviceList() {
            const deviceList = document.getElementById('deviceList');
            
            if (connectedPorts.length === 0) {
                deviceList.innerHTML = '<p style="text-align: center; color: #7f8c8d; font-style: italic;">No devices connected yet</p>';
                return;
            }

            deviceList.innerHTML = connectedPorts.map((device, index) => {
                const statusClass = device.connected ? 'connected' : 'disconnected';
                const statusText = device.connected ? 'Connected' : 'Disconnected';
                const buttonText = device.connected ? 'Disconnect' : 'Remove';
                const buttonClass = device.connected ? 'btn-danger' : 'btn-secondary';
                const itemClass = device.connected ? '' : 'device-disconnected';
                
                return `
                    <div class="device-item ${itemClass}">
                        <div class="device-info">
                            <div class="device-name">${device.name}</div>
                            <div class="device-status status ${statusClass}">${statusText}</div>
                        </div>
                        <button onclick="disconnectDevice(${index})" class="${buttonClass}">${buttonText}</button>
                    </div>
                `;
            }).join('');

            // Count only actually connected devices
            const connectedCount = connectedPorts.filter(device => device.connected).length;
            document.getElementById('connectedCount').textContent = connectedCount;
        }

        // Disconnect specific device
        async function disconnectDevice(index) {
            try {
                if (connectedPorts[index]) {
                    const deviceName = connectedPorts[index].name || `Device ${index + 1}`;
                    
                    if (connectedPorts[index].connected && connectedPorts[index].port) {
                        // Try to close the port gracefully
                        try {
                            // Release reader if it exists
                            if (connectedPorts[index].reader) {
                                try {
                                    connectedPorts[index].reader.releaseLock();
                                } catch (e) {
                                    // Ignore reader release errors
                                }
                            }
                            await connectedPorts[index].port.close();
                            log(`${deviceName} disconnected manually`);
                        } catch (closeError) {
                            log(`Error closing ${deviceName}: ${closeError.message}`, 'warning');
                        }
                    }
                    
                    // Remove from array regardless of close success
                    connectedPorts.splice(index, 1);
                    updateDeviceList();
                    updateConnectionStatus();
                }
            } catch (error) {
                log(`Error disconnecting device ${index + 1}: ${error.message}`, 'error');
            }
        }

        // Update connection status
        function updateConnectionStatus() {
            const status = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const sendBtn = document.getElementById('sendBtn');
            
            // Raw testing buttons
            const rawButtons = ['sendRawBtn', 'sendCRBtn', 'sendLFBtn', 'sendCRLFBtn'];

            if (connectedPorts.length === 0) {
                status.className = 'status disconnected';
                status.textContent = 'No devices connected';
                disconnectBtn.disabled = true;
                sendBtn.disabled = true;
                
                // Disable raw testing buttons
                rawButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = true;
                });
            } else {
                status.className = 'status connected';
                status.textContent = `${connectedPorts.length} device(s) connected`;
                disconnectBtn.disabled = false;
                sendBtn.disabled = false;
                
                // Enable raw testing buttons
                rawButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = false;
                });
            }
        }

        // NTP Time Synchronization
        async function syncTime() {
            try {
                log('Syncing with NTP server...');
                document.getElementById('syncBtn').disabled = true;
                
                // Use time.phantom.app/utc for time synchronization
                const timeServers = [
                    'https://time.phantom.app/utc'
                ];

                let serverTime = null;
                for (const server of timeServers) {
                    try {
                        const response = await fetch(server);
                        const timestampText = await response.text();
                        
                        // The API returns just a timestamp like 1750805175587
                        const timestamp = parseInt(timestampText.trim());
                        if (!isNaN(timestamp)) {
                            serverTime = new Date(timestamp);
                        }
                        
                        if (serverTime) break;
                    } catch (e) {
                        continue;
                    }
                }

                if (serverTime) {
                    const localTime = new Date();
                    ntpOffset = serverTime.getTime() - localTime.getTime();
                    
                    document.getElementById('ntpOffset').textContent = ntpOffset;
                    // Use NTP-adjusted time for last sync display
                    const ntpAdjustedTime = new Date(Date.now() + ntpOffset);
                    document.getElementById('lastSync').textContent = ntpAdjustedTime.toLocaleTimeString();
                    
                    log(`Time synchronized. Offset: ${ntpOffset}ms`);
                    log(`Local time: ${localTime.toLocaleTimeString()}, NTP time: ${serverTime.toLocaleTimeString()}`);
                } else {
                    throw new Error('Could not reach time servers');
                }
            } catch (error) {
                log(`NTP sync failed: ${error.message}`, 'error');
                // Fallback to local time
                ntpOffset = 0;
                document.getElementById('ntpOffset').textContent = '0 (Local)';
            } finally {
                document.getElementById('syncBtn').disabled = false;
            }
        }

        // Start automatic NTP sync
        function startNTPSync() {
            syncTime(); // Initial sync
            syncInterval = setInterval(syncTime, 300000); // Sync every 5 minutes
        }

        // Start Phantom time display update
        function startPhantomTimeDisplay() {
            // Update current Phantom time display every second
            phantomTimeDisplayInterval = setInterval(async () => {
                try {
                    const response = await fetch('https://time.phantom.app/utc');
                    const timestampText = await response.text();
                    const timestamp = parseInt(timestampText.trim());
                    
                    if (!isNaN(timestamp)) {
                        const phantomTime = new Date(timestamp);
                        document.getElementById('currentPhantomTime').textContent = phantomTime.toLocaleTimeString();
                    } else {
                        // Fallback to NTP-adjusted local time if phantom time fails
                        const ntpTime = new Date(Date.now() + ntpOffset);
                        document.getElementById('currentPhantomTime').textContent = ntpTime.toLocaleTimeString();
                    }
                } catch (error) {
                    // Fallback to NTP-adjusted local time if phantom time fails
                    const ntpTime = new Date(Date.now() + ntpOffset);
                    document.getElementById('currentPhantomTime').textContent = ntpTime.toLocaleTimeString();
                }
            }, 1000);
        }

        // Update scheduling mode UI
        function updateSchedulingMode() {
            const mode = document.getElementById('schedulingMode').value;
            currentSchedulingMode = mode;
            
            // Hide all mode controls
            document.getElementById('delayModeControls').style.display = 'none';
            document.getElementById('bpmModeControls').style.display = 'none';
            document.getElementById('fpsModeControls').style.display = 'none';
            document.getElementById('startMetronome').style.display = 'none';
            document.getElementById('timingInfo').style.display = 'none';
            
            // Reset tap tempo when switching modes
            resetTapTempo();
            
            // Show relevant controls
            switch(mode) {
                case 'delay':
                    document.getElementById('delayModeControls').style.display = 'grid';
                    break;
                case 'bpm':
                    document.getElementById('bpmModeControls').style.display = 'grid';
                    document.getElementById('startMetronome').style.display = 'inline-block';
                    document.getElementById('timingInfo').style.display = 'grid';
                    updateBpmTiming();
                    break;
                case 'fps':
                    document.getElementById('fpsModeControls').style.display = 'grid';
                    document.getElementById('timingInfo').style.display = 'grid';
                    updateFpsTiming();
                    break;
            }
            
            log(`Scheduling mode changed to: ${mode.toUpperCase()}`);
        }

        // Update BPM timing display
        function updateBpmTiming() {
            const bpm = parseFloat(document.getElementById('bpmInput').value);
            const division = parseInt(document.getElementById('beatDivision').value);
            const intervalMs = (60000 / bpm) / (division / 4); // Convert to milliseconds per beat division
            
            document.getElementById('currentTiming').textContent = `${intervalMs.toFixed(1)}ms`;
        }

        // Update FPS timing display
        function updateFpsTiming() {
            const fps = parseFloat(document.getElementById('fpsInput').value);
            const interval = parseInt(document.getElementById('frameInterval').value);
            const frameTimeMs = 1000 / fps;
            const executionIntervalMs = frameTimeMs * interval;
            
            document.getElementById('currentTiming').textContent = `${executionIntervalMs.toFixed(1)}ms`;
        }

        // Schedule command execution
        function scheduleCommand() {
            const command = document.getElementById('commandInput').value.trim();

            if (!command) {
                alert('Please enter a command to send');
                return;
            }

            if (connectedPorts.length === 0) {
                alert('No devices connected');
                return;
            }

            // Cancel any existing scheduled commands
            cancelScheduled();
            executionCounter = 0;
            document.getElementById('executionCount').textContent = '0';

            switch(currentSchedulingMode) {
                case 'delay':
                    scheduleDelayCommand(command);
                    break;
                case 'bpm':
                    scheduleBpmCommand(command);
                    break;
                case 'fps':
                    scheduleFpsCommand(command);
                    break;
            }
        }

        // Schedule command with time delay using NTP-synchronized execution
        function scheduleDelayCommand(command) {
            const delay = parseInt(document.getElementById('delayInput').value);
            
            // Create a synchronized execution time using NTP-adjusted time
            // Use NTP-corrected Unix timestamp for true synchronization across networks
            const currentNtpTime = Date.now() + ntpOffset;
            const currentNtpUnixTime = Math.floor(currentNtpTime / 1000);
            const syncPointUnixTime = currentNtpUnixTime + Math.ceil(delay) + 1; // Add 1 second buffer for sync
            const targetNtpExecutionTime = syncPointUnixTime * 1000; // Convert back to milliseconds
            
            // Calculate local delay accounting for NTP offset
            // We need to execute when our local time + ntpOffset equals the target NTP time
            const targetLocalTime = targetNtpExecutionTime - ntpOffset;
            const localDelayMs = targetLocalTime - Date.now();
            
            const commandId = Date.now();

            scheduledCommands.push({
                id: commandId,
                command: command,
                executeTime: targetNtpExecutionTime,
                syncPointUnixTime: syncPointUnixTime,
                devices: connectedPorts.length,
                mode: 'delay'
            });

            log(`Command scheduled for synchronized execution at NTP Unix time: ${syncPointUnixTime} (${new Date(targetNtpExecutionTime).toLocaleString()})`);
            log(`NTP target time: ${new Date(targetNtpExecutionTime).toLocaleTimeString()}, Local target: ${new Date(targetLocalTime).toLocaleTimeString()}`);
            log(`NTP offset: ${ntpOffset}ms, Local delay to sync point: ${localDelayMs}ms`);
            
            document.getElementById('commandStatus').className = 'status syncing';
            document.getElementById('commandStatus').textContent = `Command scheduled for NTP-synchronized execution at ${new Date(targetNtpExecutionTime).toLocaleTimeString()}`;
            document.getElementById('cancelBtn').disabled = false;

            // Publish sync command via MQTT for multi-device coordination
            if (mqttConnected) {
                const syncMessage = {
                    type: 'sync_command',
                    command: command,
                    syncPointUnixTime: syncPointUnixTime,
                    targetExecutionTime: targetNtpExecutionTime,
                    ntpOffset: ntpOffset, // Include our NTP offset for reference
                    source: document.getElementById('mqttClientId').value
                };
                
                mqttClient.publish('esp32/sync_commands', JSON.stringify(syncMessage), { qos: 1 }, function (err) {
                    if (!err) {
                        log(`Sync command published to MQTT for multi-device coordination`);
                    }
                });
            }

            // Execute at the exact sync point, accounting for NTP offset
            setTimeout(() => {
                const actualExecutionTime = Date.now();
                const actualNtpTime = actualExecutionTime + ntpOffset;
                const syncAccuracy = Math.abs(actualNtpTime - targetNtpExecutionTime);
                log(`Executing synchronized command (NTP accuracy: ¬±${syncAccuracy}ms from target)`);
                log(`Target NTP time: ${new Date(targetNtpExecutionTime).toLocaleTimeString()}, Actual NTP time: ${new Date(actualNtpTime).toLocaleTimeString()}`);
                executeCommand(command);
            }, Math.max(0, localDelayMs));
        }

        // Schedule command with BPM timing
        function scheduleBpmCommand(command) {
            const bpm = parseFloat(document.getElementById('bpmInput').value);
            const division = parseInt(document.getElementById('beatDivision').value);
            const beatCount = parseInt(document.getElementById('beatCount').value);
            const loop = document.getElementById('bpmLoop').checked;
            
            currentBpmLoop = loop;
            
            // Calculate interval in milliseconds
            const intervalMs = (60000 / bpm) / (division / 4);
            
            log(`Starting BPM scheduling: ${bpm} BPM, ${division} division, ${beatCount} beats, loop: ${loop}`);
            log(`Interval: ${intervalMs.toFixed(1)}ms per execution (NTP-synchronized)`);
            log(`Current NTP offset: ${ntpOffset}ms`);
            
            document.getElementById('commandStatus').className = 'status syncing';
            document.getElementById('commandStatus').textContent = `BPM scheduling active: ${bpm} BPM (NTP-sync)`;
            document.getElementById('cancelBtn').disabled = false;
            
            let currentBeat = 0;
            let nextTargetNtpTime = Date.now() + ntpOffset; // Start from current NTP time
            
            const executeBpmCommand = () => {
                if (currentBeat < beatCount || loop) {
                    // Log the actual NTP time of execution
                    const actualNtpTime = Date.now() + ntpOffset;
                    log(`BPM beat ${currentBeat + 1} executed at NTP time: ${new Date(actualNtpTime).toLocaleTimeString()}`);
                    
                    executeCommand(command);
                    executionCounter++;
                    document.getElementById('executionCount').textContent = executionCounter;
                    
                    currentBeat++;
                    if (loop && currentBeat >= beatCount) {
                        currentBeat = 0; // Reset for loop
                    }
                    
                    if (currentBeat < beatCount || loop) {
                        // Calculate next target NTP time
                        nextTargetNtpTime += intervalMs;
                        
                        // Calculate local delay needed to hit target NTP time
                        const currentLocalTime = Date.now();
                        const targetLocalTime = nextTargetNtpTime - ntpOffset;
                        const localDelay = targetLocalTime - currentLocalTime;
                        
                        // Update display with target NTP time
                        document.getElementById('nextExecution').textContent =
                            new Date(nextTargetNtpTime).toLocaleTimeString() + ' (NTP target)';
                        
                        // Schedule next execution to hit exact NTP time
                        bpmInterval = setTimeout(executeBpmCommand, Math.max(0, localDelay));
                        
                        log(`Next BPM beat scheduled for NTP time: ${new Date(nextTargetNtpTime).toLocaleTimeString()}, local delay: ${localDelay.toFixed(1)}ms`);
                    } else {
                        document.getElementById('commandStatus').className = 'status connected';
                        document.getElementById('commandStatus').textContent = 'BPM sequence completed';
                        document.getElementById('cancelBtn').disabled = true;
                    }
                }
            };
            
            // Start immediately
            executeBpmCommand();
        }

        // Schedule command with FPS timing
        function scheduleFpsCommand(command) {
            const fps = parseFloat(document.getElementById('fpsInput').value);
            const frameInterval = parseInt(document.getElementById('frameInterval').value);
            const totalFrames = parseInt(document.getElementById('totalFrames').value);
            const loop = document.getElementById('fpsLoop').checked;
            
            currentFpsLoop = loop;
            
            // Calculate timing
            const frameTimeMs = 1000 / fps;
            const executionIntervalMs = frameTimeMs * frameInterval;
            const totalExecutions = Math.ceil(totalFrames / frameInterval);
            
            log(`Starting FPS scheduling: ${fps} FPS, every ${frameInterval} frames, ${totalFrames} total frames, loop: ${loop}`);
            log(`Interval: ${executionIntervalMs.toFixed(1)}ms per execution (NTP-synchronized)`);
            log(`Current NTP offset: ${ntpOffset}ms`);
            
            document.getElementById('commandStatus').className = 'status syncing';
            document.getElementById('commandStatus').textContent = `FPS scheduling active: ${fps} FPS (NTP-sync)`;
            document.getElementById('cancelBtn').disabled = false;
            
            let currentExecution = 0;
            let nextTargetNtpTime = Date.now() + ntpOffset; // Start from current NTP time
            
            const executeFpsCommand = () => {
                if (currentExecution < totalExecutions || loop) {
                    // Log the actual NTP time of execution
                    const actualNtpTime = Date.now() + ntpOffset;
                    log(`FPS frame ${currentExecution + 1} executed at NTP time: ${new Date(actualNtpTime).toLocaleTimeString()}`);
                    
                    executeCommand(command);
                    executionCounter++;
                    document.getElementById('executionCount').textContent = executionCounter;
                    
                    currentExecution++;
                    if (loop && currentExecution >= totalExecutions) {
                        currentExecution = 0; // Reset for loop
                    }
                    
                    if (currentExecution < totalExecutions || loop) {
                        // Calculate next target NTP time
                        nextTargetNtpTime += executionIntervalMs;
                        
                        // Calculate local delay needed to hit target NTP time
                        const currentLocalTime = Date.now();
                        const targetLocalTime = nextTargetNtpTime - ntpOffset;
                        const localDelay = targetLocalTime - currentLocalTime;
                        
                        // Update display with target NTP time
                        document.getElementById('nextExecution').textContent =
                            new Date(nextTargetNtpTime).toLocaleTimeString() + ' (NTP target)';
                        
                        // Schedule next execution to hit exact NTP time
                        fpsInterval = setTimeout(executeFpsCommand, Math.max(0, localDelay));
                        
                        log(`Next FPS frame scheduled for NTP time: ${new Date(nextTargetNtpTime).toLocaleTimeString()}, local delay: ${localDelay.toFixed(1)}ms`);
                    } else {
                        document.getElementById('commandStatus').className = 'status connected';
                        document.getElementById('commandStatus').textContent = 'FPS sequence completed';
                        document.getElementById('cancelBtn').disabled = true;
                    }
                }
            };
            
            // Start immediately
            executeFpsCommand();
        }

        // Execute command immediately
        async function executeCommand(command) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command); // Raw command without line endings

                // Send to all connected devices simultaneously
                const promises = connectedPorts.map(async (device, index) => {
                    try {
                        // Check if device is still connected
                        if (!device.connected) {
                            log(`Skipping disconnected device ${index + 1}`, 'warning');
                            return;
                        }

                        if (!device.port || !device.port.writable) {
                            log(`Device ${index + 1} port not writable, marking as disconnected`, 'warning');
                            handleDeviceDisconnect(index);
                            return;
                        }
                        
                        const writer = device.port.writable.getWriter();
                        await writer.write(data);
                        await writer.ready;
                        writer.releaseLock();
                        
                        // Display in monitor
                        displayInMonitor(data, `TX Dev${index + 1}`);
                    } catch (error) {
                        log(`Failed to send to device ${index + 1}: ${error.message}`, 'error');
                        
                        // Check if this is a disconnection error
                        if (error.name === 'NetworkError' ||
                            error.name === 'NotReadableError' ||
                            error.message.includes('device has been lost') ||
                            error.message.includes('disconnected') ||
                            error.message.includes('not open')) {
                            log(`Device ${index + 1} disconnected during write operation`, 'warning');
                            handleDeviceDisconnect(index);
                        }
                    }
                });

                await Promise.all(promises);
                log(`Command executed (raw): "${command}"`);

            } catch (error) {
                log(`Command execution failed: ${error.message}`, 'error');
            }
        }

        // Toggle metronome for BPM mode
        function toggleMetronome() {
            const btn = document.getElementById('startMetronome');
            
            if (!isMetronomeRunning) {
                startMetronome();
                btn.textContent = 'üîá Stop Metronome';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-danger');
            } else {
                stopMetronome();
                btn.textContent = 'üéµ Start Metronome';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-success');
            }
        }

        // Start metronome
        function startMetronome() {
            const bpm = parseFloat(document.getElementById('bpmInput').value);
            const division = parseInt(document.getElementById('beatDivision').value);
            const intervalMs = (60000 / bpm) / (division / 4);
            
            isMetronomeRunning = true;
            
            // Create audio context for metronome clicks
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const playClick = (isAccent = false) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = isAccent ? 800 : 400;
                oscillator.type = 'square';
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            };
            
            let beatCounter = 0;
            const beatsPerMeasure = 4;
            
            const metronomeClick = () => {
                if (isMetronomeRunning) {
                    playClick(beatCounter % beatsPerMeasure === 0);
                    beatCounter++;
                    metronomeInterval = setTimeout(metronomeClick, intervalMs);
                }
            };
            
            metronomeClick();
            log(`Metronome started at ${bpm} BPM`);
        }

        // Stop metronome
        function stopMetronome() {
            isMetronomeRunning = false;
            if (metronomeInterval) {
                clearTimeout(metronomeInterval);
            }
            log('Metronome stopped');
        }

        // Tap tempo functionality
        function tapTempo() {
            const now = Date.now();
            const tapBtn = document.getElementById('tapTempoBtn');
            const tapInfo = document.getElementById('tapTempoInfo');
            
            // Show info on first tap
            if (tapTimes.length === 0) {
                tapInfo.style.display = 'block';
            }
            
            // Add current tap time
            tapTimes.push(now);
            
            // Visual feedback - flash the button
            tapBtn.style.transform = 'scale(0.95)';
            tapBtn.style.backgroundColor = '#e74c3c';
            setTimeout(() => {
                tapBtn.style.transform = 'scale(1)';
                tapBtn.style.backgroundColor = '';
            }, 100);
            
            // Keep only recent taps (last 8 taps or taps within 10 seconds)
            const tenSecondsAgo = now - 10000;
            tapTimes = tapTimes.filter(time => time > tenSecondsAgo).slice(-8);
            
            // Need at least 2 taps to calculate BPM
            if (tapTimes.length >= 2) {
                // Calculate intervals between taps
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i - 1]);
                }
                
                // Calculate average interval
                const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
                
                // Convert to BPM (60000 ms per minute)
                const bpm = Math.round((60000 / avgInterval) * 10) / 10; // Round to 1 decimal place
                
                // Clamp BPM to reasonable range
                const clampedBpm = Math.max(30, Math.min(300, bpm));
                
                // Update BPM input
                document.getElementById('bpmInput').value = clampedBpm;
                
                // Update timing display
                updateBpmTiming();
                
                // Update button text to show current BPM
                tapBtn.textContent = `ü•Å ${clampedBpm} BPM`;
                
                log(`Tap tempo: ${clampedBpm} BPM (${tapTimes.length} taps, ${avgInterval.toFixed(1)}ms avg interval)`);
            } else {
                tapBtn.textContent = `ü•Å Tap ${2 - tapTimes.length} more`;
            }
            
            // Clear tap timeout if it exists
            if (tapTimeoutId) {
                clearTimeout(tapTimeoutId);
            }
            
            // Reset after 5 seconds of no tapping
            tapTimeoutId = setTimeout(() => {
                resetTapTempo();
            }, 5000);
        }

        // Reset tap tempo
        function resetTapTempo() {
            tapTimes = [];
            const tapBtn = document.getElementById('tapTempoBtn');
            const tapInfo = document.getElementById('tapTempoInfo');
            
            tapBtn.textContent = 'ü•Å Tap Tempo';
            tapInfo.style.display = 'none';
            
            if (tapTimeoutId) {
                clearTimeout(tapTimeoutId);
                tapTimeoutId = null;
            }
        }


        // Cancel scheduled commands
        function cancelScheduled() {
            scheduledCommands = [];
            
            // Clear all intervals
            if (bpmInterval) {
                clearTimeout(bpmInterval);
                bpmInterval = null;
            }
            if (fpsInterval) {
                clearTimeout(fpsInterval);
                fpsInterval = null;
            }
            
            // Stop metronome if running
            if (isMetronomeRunning) {
                stopMetronome();
                const btn = document.getElementById('startMetronome');
                btn.textContent = 'üéµ Start Metronome';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-success');
            }
            
            document.getElementById('commandStatus').className = 'status disconnected';
            document.getElementById('commandStatus').textContent = 'Scheduled commands cancelled';
            document.getElementById('cancelBtn').disabled = true;
            document.getElementById('nextExecution').textContent = '--';
            
            log('All scheduled commands cancelled');
        }

        // Logging function
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            // Use NTP-adjusted time for logging timestamps
            const ntpAdjustedTime = new Date(Date.now() + ntpOffset);
            const timestamp = ntpAdjustedTime.toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            let prefix = '[INFO]';
            if (type === 'error') prefix = '[ERROR]';
            if (type === 'warning') prefix = '[WARN]';
            
            // Show NTP offset in timestamp if significant (>100ms)
            const timestampDisplay = Math.abs(ntpOffset) > 100 ?
                `${timestamp} (NTP¬±${ntpOffset}ms)` : timestamp;
            
            logEntry.innerHTML = `<span class="log-timestamp">${timestampDisplay} ${prefix}</span>${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Clear log
        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
            log('Log cleared');
        }

        // Enhanced Serial Monitor Functions
        let monitorPaused = false;
        let totalBytesReceived = 0;
        let lastByteTime = Date.now();
        let dataRateInterval;

        function displayInMonitor(data, source) {
            if (monitorPaused) return;
            
            const monitor = document.getElementById('serialMonitor');
            const hexDisplay = document.getElementById('hexDisplay').checked;
            const autoScroll = document.getElementById('autoScroll').checked;
            const showTimestamps = document.getElementById('showTimestamps').checked;
            const filterEmpty = document.getElementById('filterEmpty').checked;
            
            // Filter empty data if option is enabled
            if (filterEmpty && data.length === 0) return;
            
            // Update byte counter and data rate
            totalBytesReceived += data.length;
            document.getElementById('byteCount').textContent = totalBytesReceived.toLocaleString();
            updateDataRate(data.length);
            
            // Use NTP-adjusted timestamp for serial monitor
            const ntpAdjustedTime = new Date(Date.now() + ntpOffset);
            const timestamp = ntpAdjustedTime.toLocaleTimeString();
            const entry = document.createElement('div');
            entry.style.marginBottom = '1px';
            entry.style.padding = '1px 5px';
            entry.style.borderRadius = '2px';
            entry.style.fontFamily = "'Consolas', 'Monaco', 'Courier New', monospace";
            entry.style.fontSize = '12px';
            entry.style.lineHeight = '1.2';
            
            let displayText;
            if (hexDisplay) {
                // Convert to hex with ASCII preview like screen/minicom
                const hexArray = Array.from(data).map(byte =>
                    byte.toString(16).padStart(2, '0').toUpperCase()
                ).join(' ');
                
                // Add ASCII representation
                const asciiArray = Array.from(data).map(byte => {
                    if (byte >= 32 && byte <= 126) {
                        return String.fromCharCode(byte);
                    } else if (byte === 9) return '\\t';
                    else if (byte === 10) return '\\n';
                    else if (byte === 13) return '\\r';
                    else return '.';
                }).join('');
                
                displayText = showTimestamps ?
                    `[${timestamp}] ${source}: ${hexArray} | ${asciiArray}` :
                    `${source}: ${hexArray} | ${asciiArray}`;
            } else {
                // Improved text display with proper control character handling
                const decoder = new TextDecoder('utf-8', { fatal: false, ignoreBOM: true });
                let text;
                
                try {
                    text = decoder.decode(data, { stream: false });
                } catch (e) {
                    // Fallback for invalid UTF-8
                    text = Array.from(data).map(byte =>
                        byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : `\\x${byte.toString(16).padStart(2, '0')}`
                    ).join('');
                }
                
                // Handle control characters more like terminal emulators
                const processedText = text
                    .replace(/\r\n/g, '‚Üµ\n')  // CRLF
                    .replace(/\r/g, '‚èé')      // CR only
                    .replace(/\n/g, '‚Üµ\n')    // LF (preserve actual newlines)
                    .replace(/\t/g, '‚Üí')      // Tab
                    .replace(/\x00/g, '‚àÖ')    // NULL
                    .replace(/\x07/g, 'üîî')   // Bell
                    .replace(/\x08/g, '‚å´')    // Backspace
                    .replace(/\x1b/g, '‚éã')    // Escape
                    .replace(/[\x01-\x06\x0e-\x1f]/g, (match) => `^${String.fromCharCode(match.charCodeAt(0) + 64)}`);
                
                displayText = showTimestamps ?
                    `[${timestamp}] ${source}: ${processedText}` :
                    `${source}: ${processedText}`;
            }
            
            // Handle multi-line display properly
            const lines = displayText.split('\n');
            lines.forEach((line, lineIndex) => {
                if (lineIndex > 0) {
                    const lineEntry = document.createElement('div');
                    lineEntry.style.marginBottom = '1px';
                    lineEntry.style.padding = '1px 5px';
                    lineEntry.style.borderRadius = '2px';
                    lineEntry.style.fontFamily = "'Consolas', 'Monaco', 'Courier New', monospace";
                    lineEntry.style.fontSize = '12px';
                    lineEntry.style.lineHeight = '1.2';
                    lineEntry.textContent = line;
                    
                    // Color coding
                    if (source.includes('TX')) {
                        lineEntry.style.color = '#ff7b72';
                        lineEntry.style.backgroundColor = 'rgba(255, 123, 114, 0.05)';
                    } else {
                        lineEntry.style.color = '#7ee787';
                        lineEntry.style.backgroundColor = 'rgba(126, 231, 135, 0.05)';
                    }
                    
                    monitor.appendChild(lineEntry);
                } else {
                    entry.textContent = line;
                    
                    // Enhanced color coding
                    if (source.includes('TX')) {
                        entry.style.color = '#ff7b72';
                        entry.style.backgroundColor = 'rgba(255, 123, 114, 0.05)';
                    } else {
                        entry.style.color = '#7ee787';
                        entry.style.backgroundColor = 'rgba(126, 231, 135, 0.05)';
                    }
                    
                    monitor.appendChild(entry);
                }
            });
            
            // Limit monitor entries to prevent memory issues
            const maxEntries = 2000;
            while (monitor.children.length > maxEntries) {
                monitor.removeChild(monitor.firstChild);
            }
            
            if (autoScroll) {
                monitor.scrollTop = monitor.scrollHeight;
            }
        }

        function clearMonitor() {
            document.getElementById('serialMonitor').innerHTML =
                '<div style="color: #7d8590; font-style: italic;">üîç Monitor cleared. Waiting for serial data...</div>';
            totalBytesReceived = 0;
            document.getElementById('byteCount').textContent = '0';
            document.getElementById('dataRate').textContent = '0 B/s';
        }

        function pauseMonitor() {
            const pauseBtn = document.getElementById('pauseBtn');
            monitorPaused = !monitorPaused;
            
            if (monitorPaused) {
                pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
                pauseBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
                log('Serial monitor paused');
            } else {
                pauseBtn.textContent = '‚è∏Ô∏è Pause';
                pauseBtn.style.background = 'linear-gradient(135deg, #f39c12 0%, #e67e22 100%)';
                log('Serial monitor resumed');
            }
        }

        function saveMonitorLog() {
            const monitor = document.getElementById('serialMonitor');
            const logContent = Array.from(monitor.children)
                .map(entry => entry.textContent)
                .join('\n');
            
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `serial_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('Serial monitor log saved');
        }

        function updateDataRate(bytesReceived) {
            const now = Date.now();
            const timeDiff = (now - lastByteTime) / 1000; // seconds
            
            if (timeDiff > 0) {
                const rate = bytesReceived / timeDiff;
                let rateText;
                
                if (rate < 1024) {
                    rateText = `${rate.toFixed(1)} B/s`;
                } else if (rate < 1024 * 1024) {
                    rateText = `${(rate / 1024).toFixed(1)} KB/s`;
                } else {
                    rateText = `${(rate / (1024 * 1024)).toFixed(1)} MB/s`;
                }
                
                document.getElementById('dataRate').textContent = rateText;
            }
            
            lastByteTime = now;
        }

        function updateBaudRate() {
            const newBaudRate = parseInt(document.getElementById('baudRateDisplay').value);
            log(`Baud rate setting changed to ${newBaudRate} (will apply to new connections)`);
            
            // Store the baud rate for future connections
            window.selectedBaudRate = newBaudRate;
        }

        // Initialize data rate monitoring
        function startDataRateMonitoring() {
            dataRateInterval = setInterval(() => {
                // Reset data rate if no data received recently
                if (Date.now() - lastByteTime > 2000) {
                    document.getElementById('dataRate').textContent = '0 B/s';
                }
            }, 1000);
        }

        // Start connection health monitoring
        function startConnectionHealthMonitoring() {
            connectionHealthInterval = setInterval(() => {
                checkConnectionHealth();
            }, 3000); // Check every 3 seconds
        }

        // Check connection health for all devices
        function checkConnectionHealth() {
            connectedPorts.forEach((device, index) => {
                if (device.connected && device.port) {
                    // Check if port is still readable/writable
                    if (!device.port.readable || !device.port.writable) {
                        log(`Device ${index + 1} connection lost (port not readable/writable)`, 'warning');
                        handleDeviceDisconnect(index);
                    }
                }
            });
        }

        // Raw input handler - send characters as you type
        document.addEventListener('DOMContentLoaded', function() {
            const rawInput = document.getElementById('rawInput');
            if (rawInput) {
                rawInput.addEventListener('input', function(e) {
                    if (connectedPorts.length > 0 && e.target.value) {
                        const char = e.target.value.slice(-1); // Get the last character typed
                        sendRawCharacter(char);
                        e.target.value = ''; // Clear input for next character
                    }
                });
            }
        });

        // Send raw character immediately
        async function sendRawCharacter(char) {
            try {
                // Handle special characters and escape sequences
                let actualChar = char;
                if (char === '\\' && document.getElementById('rawInput').value.length > 1) {
                    // Handle escape sequences like \n, \r, \t
                    const nextChar = document.getElementById('rawInput').value[1];
                    switch (nextChar) {
                        case 'n': actualChar = '\n'; break;
                        case 'r': actualChar = '\r'; break;
                        case 't': actualChar = '\t'; break;
                        case '\\': actualChar = '\\'; break;
                        default: actualChar = char;
                    }
                }
                
                const encoder = new TextEncoder();
                const data = encoder.encode(actualChar);
                
                displayInMonitor(data, 'TX Raw');
                
                const promises = connectedPorts.map(async (device, index) => {
                    try {
                        if (!device.port.writable) {
                            throw new Error('Port not writable');
                        }
                        
                        const writer = device.port.writable.getWriter();
                        await writer.write(data);
                        await writer.ready;
                        writer.releaseLock();
                    } catch (error) {
                        log(`Failed to send raw to device ${index + 1}: ${error.message}`, 'error');
                    }
                });
                
                await Promise.all(promises);
                
                // Better logging with hex representation
                const hexCode = actualChar.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase();
                log(`Raw character sent: "${actualChar}" (0x${hexCode}, ${actualChar.charCodeAt(0)})`);
            } catch (error) {
                log(`Raw send failed: ${error.message}`, 'error');
            }
        }

        // Send raw command without line ending
        async function sendRaw() {
            const command = document.getElementById('testCommand').value;
            if (!command) return;
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command);
                
                displayInMonitor(data, 'TX Raw');
                
                const promises = connectedPorts.map(async (device, index) => {
                    try {
                        if (!device.port.writable) {
                            throw new Error('Port not writable');
                        }
                        
                        const writer = device.port.writable.getWriter();
                        await writer.write(data);
                        await writer.ready;
                        writer.releaseLock();
                    } catch (error) {
                        log(`Failed to send raw to device ${index + 1}: ${error.message}`, 'error');
                    }
                });
                
                await Promise.all(promises);
                log(`Raw command sent: "${command}"`);
            } catch (error) {
                log(`Raw send failed: ${error.message}`, 'error');
            }
        }

        // Send command with CR (\r)
        async function sendWithCR() {
            const command = document.getElementById('testCommand').value;
            if (!command) return;
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\r');
                
                displayInMonitor(data, 'TX +CR');
                
                const promises = connectedPorts.map(async (device, index) => {
                    try {
                        if (!device.port.writable) {
                            throw new Error('Port not writable');
                        }
                        
                        const writer = device.port.writable.getWriter();
                        await writer.write(data);
                        await writer.ready;
                        writer.releaseLock();
                    } catch (error) {
                        log(`Failed to send CR to device ${index + 1}: ${error.message}`, 'error');
                    }
                });
                
                await Promise.all(promises);
                log(`Command sent with CR: "${command}\\r"`);
            } catch (error) {
                log(`CR send failed: ${error.message}`, 'error');
            }
        }

        // Send command with LF (\n)
        async function sendWithLF() {
            const command = document.getElementById('testCommand').value;
            if (!command) return;
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\n');
                
                displayInMonitor(data, 'TX +LF');
                
                const promises = connectedPorts.map(async (device, index) => {
                    try {
                        if (!device.port.writable) {
                            throw new Error('Port not writable');
                        }
                        
                        const writer = device.port.writable.getWriter();
                        await writer.write(data);
                        await writer.ready;
                        writer.releaseLock();
                    } catch (error) {
                        log(`Failed to send LF to device ${index + 1}: ${error.message}`, 'error');
                    }
                });
                
                await Promise.all(promises);
                log(`Command sent with LF: "${command}\\n"`);
            } catch (error) {
                log(`LF send failed: ${error.message}`, 'error');
            }
        }

        // Send command with CRLF (\r\n)
        async function sendWithCRLF() {
            const command = document.getElementById('testCommand').value;
            if (!command) return;
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\r\n');
                
                displayInMonitor(data, 'TX +CRLF');
                
                const promises = connectedPorts.map(async (device, index) => {
                    try {
                        if (!device.port.writable) {
                            throw new Error('Port not writable');
                        }
                        
                        const writer = device.port.writable.getWriter();
                        await writer.write(data);
                        await writer.ready;
                        writer.releaseLock();
                    } catch (error) {
                        log(`Failed to send CRLF to device ${index + 1}: ${error.message}`, 'error');
                    }
                });
                
                await Promise.all(promises);
                log(`Command sent with CRLF: "${command}\\r\\n"`);
            } catch (error) {
                log(`CRLF send failed: ${error.message}`, 'error');
            }
        }

        // MQTT Functions
        function initializeMqtt() {
            // Generate a unique client ID
            const clientId = 'esp32-control-' + Math.random().toString(36).substr(2, 9);
            document.getElementById('mqttClientId').value = clientId;
            log('MQTT initialized with client ID: ' + clientId);
        }

        async function connectMqtt() {
            try {
                let brokerUrl = document.getElementById('mqttBroker').value.trim();
                const clientId = document.getElementById('mqttClientId').value.trim();
                const username = document.getElementById('mqttUsername').value.trim();
                const password = document.getElementById('mqttPassword').value.trim();

                if (!brokerUrl) {
                    alert('Please enter a MQTT broker URL');
                    return;
                }

                // Ensure proper WebSocket URL format for HiveMQ Cloud
                if (!brokerUrl.startsWith('ws://') && !brokerUrl.startsWith('wss://')) {
                    // If it's a HiveMQ Cloud URL without protocol, add wss://
                    if (brokerUrl.includes('.hivemq.cloud')) {
                        brokerUrl = 'wss://' + brokerUrl;
                    } else {
                        brokerUrl = 'wss://' + brokerUrl;
                    }
                }

                // Ensure the URL ends with /mqtt for WebSocket connections
                if (!brokerUrl.endsWith('/mqtt')) {
                    brokerUrl = brokerUrl + '/mqtt';
                }

                // Update the input field with the corrected URL
                document.getElementById('mqttBroker').value = brokerUrl;

                log('Connecting to MQTT broker: ' + brokerUrl);
                document.getElementById('connectMqttBtn').disabled = true;

                const options = {
                    clientId: clientId,
                    clean: true,
                    connectTimeout: 10000, // Increased timeout for cloud connections
                    reconnectPeriod: 1000,
                    keepalive: 60,
                    protocolVersion: 4, // Use MQTT 3.1.1
                };

                // HiveMQ Cloud requires authentication
                if (brokerUrl.includes('.hivemq.cloud')) {
                    if (!username || !password) {
                        alert('HiveMQ Cloud requires username and password. Please enter your credentials.');
                        document.getElementById('connectMqttBtn').disabled = false;
                        return;
                    }
                    options.username = username;
                    options.password = password;
                } else if (username) {
                    options.username = username;
                    options.password = password;
                }

                log('Connection options: ' + JSON.stringify({...options, password: '***'}));
                mqttClient = mqtt.connect(brokerUrl, options);

                mqttClient.on('connect', function (connack) {
                    mqttConnected = true;
                    log('Connected to MQTT broker successfully');
                    log('Connection acknowledged: ' + JSON.stringify(connack));
                    updateMqttConnectionStatus();
                    document.getElementById('connectMqttBtn').disabled = false;
                    
                    // Auto-subscribe to rhythm control topic if enabled
                    if (document.getElementById('autoSubscribeRhythm').checked) {
                        subscribeToRhythmTopic();
                    }
                });

                mqttClient.on('error', function (error) {
                    log('MQTT connection error: ' + error.message, 'error');
                    log('Error details: ' + JSON.stringify(error));
                    mqttConnected = false;
                    updateMqttConnectionStatus();
                    document.getElementById('connectMqttBtn').disabled = false;
                });

                mqttClient.on('close', function () {
                    log('MQTT connection closed', 'warning');
                    mqttConnected = false;
                    updateMqttConnectionStatus();
                });

                mqttClient.on('offline', function () {
                    log('MQTT client went offline', 'warning');
                    mqttConnected = false;
                    updateMqttConnectionStatus();
                });

                mqttClient.on('reconnect', function () {
                    log('MQTT client attempting to reconnect...');
                });

                mqttClient.on('message', function (topic, message) {
                    handleMqttMessage(topic, message.toString());
                });

                // Add connection timeout
                setTimeout(() => {
                    if (!mqttConnected) {
                        log('MQTT connection timeout - please check your credentials and network', 'error');
                        document.getElementById('connectMqttBtn').disabled = false;
                    }
                }, 15000);

            } catch (error) {
                log('MQTT connection failed: ' + error.message, 'error');
                document.getElementById('connectMqttBtn').disabled = false;
            }
        }

        function disconnectMqtt() {
            if (mqttClient) {
                mqttClient.end();
                mqttClient = null;
                mqttConnected = false;
                subscribedTopics = [];
                updateMqttConnectionStatus();
                updateMqttSubscriptionStatus();
                log('Disconnected from MQTT broker');
            }
        }

        function updateMqttConnectionStatus() {
            const status = document.getElementById('mqttConnectionStatus');
            const connectBtn = document.getElementById('connectMqttBtn');
            const disconnectBtn = document.getElementById('disconnectMqttBtn');
            const subscribeBtn = document.getElementById('subscribeMqttBtn');
            const publishBtn = document.getElementById('publishMqttBtn');

            if (mqttConnected) {
                status.className = 'status connected';
                status.textContent = 'Connected to MQTT broker';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                subscribeBtn.disabled = false;
                publishBtn.disabled = false;
            } else {
                status.className = 'status disconnected';
                status.textContent = 'MQTT not connected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                subscribeBtn.disabled = true;
                publishBtn.disabled = true;
                document.getElementById('unsubscribeMqttBtn').disabled = true;
            }
        }

        function subscribeMqtt() {
            if (!mqttClient || !mqttConnected) {
                alert('Please connect to MQTT broker first');
                return;
            }

            const topic = document.getElementById('mqttTopic').value.trim();
            const qos = parseInt(document.getElementById('mqttQos').value);

            if (!topic) {
                alert('Please enter a topic to subscribe to');
                return;
            }

            mqttClient.subscribe(topic, { qos: qos }, function (err) {
                if (err) {
                    log('MQTT subscription failed: ' + err.message, 'error');
                } else {
                    subscribedTopics.push({ topic: topic, qos: qos });
                    log('Subscribed to MQTT topic: ' + topic + ' (QoS ' + qos + ')');
                    updateMqttSubscriptionStatus();
                }
            });
        }

        function unsubscribeMqtt() {
            if (!mqttClient || !mqttConnected) {
                return;
            }

            const topic = document.getElementById('mqttTopic').value.trim();

            if (!topic) {
                alert('Please enter a topic to unsubscribe from');
                return;
            }

            mqttClient.unsubscribe(topic, function (err) {
                if (err) {
                    log('MQTT unsubscription failed: ' + err.message, 'error');
                } else {
                    subscribedTopics = subscribedTopics.filter(sub => sub.topic !== topic);
                    log('Unsubscribed from MQTT topic: ' + topic);
                    updateMqttSubscriptionStatus();
                }
            });
        }

        function publishMqtt() {
            if (!mqttClient || !mqttConnected) {
                alert('Please connect to MQTT broker first');
                return;
            }

            const topic = document.getElementById('publishTopic').value.trim();
            const message = document.getElementById('publishMessage').value.trim();
            const qos = parseInt(document.getElementById('mqttQos').value);

            if (!topic || !message) {
                alert('Please enter both topic and message');
                return;
            }

            mqttClient.publish(topic, message, { qos: qos }, function (err) {
                if (err) {
                    log('MQTT publish failed: ' + err.message, 'error');
                } else {
                    log('Published to MQTT topic: ' + topic + ' - Message: ' + message);
                    // Use NTP-adjusted timestamp for published messages
                    const ntpAdjustedTimestamp = new Date(Date.now() + ntpOffset);
                    displayMqttMessage(topic, message, 'PUBLISHED', ntpAdjustedTimestamp);
                }
            });
        }

        function updateMqttSubscriptionStatus() {
            const status = document.getElementById('mqttSubscriptionStatus');
            const unsubscribeBtn = document.getElementById('unsubscribeMqttBtn');

            if (subscribedTopics.length > 0) {
                status.className = 'status connected';
                status.textContent = 'Subscribed to ' + subscribedTopics.length + ' topic(s): ' +
                    subscribedTopics.map(sub => sub.topic).join(', ');
                unsubscribeBtn.disabled = false;
            } else {
                status.className = 'status disconnected';
                status.textContent = 'No active subscriptions';
                unsubscribeBtn.disabled = true;
            }
        }

        function handleMqttMessage(topic, message) {
            // Use NTP-adjusted timestamp for MQTT message handling
            const ntpAdjustedTimestamp = new Date(Date.now() + ntpOffset);
            log('MQTT message received on topic "' + topic + '": ' + message);
            displayMqttMessage(topic, message, 'RECEIVED', ntpAdjustedTimestamp);

            // Handle synchronized command coordination
            if (topic === 'esp32/sync_commands') {
                handleSyncCommand(message);
                return;
            }

            // Handle special rhythm control topic
            if (topic === 'trigger_rhythm') {
                handleRhythmControl(message);
                return;
            }

            // Auto-execute if enabled and we have connected serial devices
            if (document.getElementById('autoExecuteMqtt').checked && connectedPorts.length > 0) {
                log('Auto-executing MQTT command on serial devices: ' + message);
                syncToWholeSecondAndExecute(message);
            }
        }

        // Sync to nearest whole second and execute command
        async function syncToWholeSecondAndExecute(command) {
            try {
                // Get current phantom time to calculate sync point
                const response = await fetch('https://time.phantom.app/utc');
                const timestampText = await response.text();
                const currentPhantomTime = parseInt(timestampText.trim());
                
                if (isNaN(currentPhantomTime)) {
                    // Fallback to local time with NTP offset if phantom time fails
                    const fallbackTime = Date.now() + ntpOffset;
                    syncToWholeSecondWithTime(command, fallbackTime);
                    return;
                }
                
                syncToWholeSecondWithTime(command, currentPhantomTime);
                
            } catch (error) {
                log('Failed to get phantom time for sync, using fallback: ' + error.message, 'warning');
                // Fallback to local time with NTP offset
                const fallbackTime = Date.now() + ntpOffset;
                syncToWholeSecondWithTime(command, fallbackTime);
            }
        }

        // Sync to whole second with given time and execute command
        function syncToWholeSecondWithTime(command, currentTime) {
            // Calculate milliseconds until next whole second
            const msInCurrentSecond = currentTime % 1000;
            const msUntilNextSecond = msInCurrentSecond === 0 ? 0 : 1000 - msInCurrentSecond;
            
            const nextWholeSecond = currentTime + msUntilNextSecond;
            const nextWholeSecondDate = new Date(nextWholeSecond);
            
            log(`MQTT command will execute at next whole second: ${nextWholeSecondDate.toLocaleTimeString()}.000 (${msUntilNextSecond}ms delay)`);
            log(`Current time: ${new Date(currentTime).toLocaleTimeString()}.${String(msInCurrentSecond).padStart(3, '0')}`);
            
            // Schedule execution at the exact whole second
            setTimeout(() => {
                const actualExecutionTime = Date.now();
                log(`Executing MQTT command at: ${new Date(actualExecutionTime).toLocaleTimeString()}.${String(actualExecutionTime % 1000).padStart(3, '0')}`);
                executeCommand(command);
            }, msUntilNextSecond);
        }
        
        // Handle synchronized command execution from MQTT
        function handleSyncCommand(message) {
            try {
                const syncData = JSON.parse(message);
                const myClientId = document.getElementById('mqttClientId').value;
                
                // Ignore messages from ourselves to prevent loops
                if (syncData.source === myClientId) {
                    return;
                }
                
                log(`Received sync command from ${syncData.source}: ${syncData.type}`);
                
                if (syncData.type === 'sync_command') {
                    // Handle single synchronized command
                    const targetNtpExecutionTime = syncData.targetExecutionTime;
                    
                    // Calculate local delay accounting for our NTP offset
                    // We need to execute when our local time + ntpOffset equals the target NTP time
                    const targetLocalTime = targetNtpExecutionTime - ntpOffset;
                    const localDelay = targetLocalTime - Date.now();
                    
                    if (localDelay > 0) {
                        log(`Joining synchronized execution at NTP time ${new Date(targetNtpExecutionTime).toLocaleTimeString()}`);
                        log(`Local target time: ${new Date(targetLocalTime).toLocaleTimeString()}, delay: ${localDelay}ms`);
                        log(`Using NTP offset: ${ntpOffset}ms`);
                        
                        setTimeout(() => {
                            const actualExecutionTime = Date.now();
                            const actualNtpTime = actualExecutionTime + ntpOffset;
                            const syncAccuracy = Math.abs(actualNtpTime - targetNtpExecutionTime);
                            log(`Executing synchronized command (NTP accuracy: ¬±${syncAccuracy}ms from target)`);
                            log(`Target NTP: ${new Date(targetNtpExecutionTime).toLocaleTimeString()}, Actual NTP: ${new Date(actualNtpTime).toLocaleTimeString()}`);
                            executeCommand(syncData.command);
                        }, localDelay);
                    } else {
                        log(`Sync command target time already passed (${Math.abs(localDelay)}ms ago), skipping execution`);
                    }
                    
                } else if (syncData.type === 'sync_bpm') {
                    // Handle synchronized BPM sequence
                    const startNtpExecutionTime = syncData.startExecutionTime;
                    
                    // Calculate local delay accounting for our NTP offset
                    const startLocalTime = startNtpExecutionTime - ntpOffset;
                    const initialDelay = startLocalTime - Date.now();
                    
                    if (initialDelay > -5000) { // Allow joining within 5 seconds of start
                        log(`Joining synchronized BPM sequence: ${syncData.bpm} BPM, ${syncData.division} division`);
                        log(`Start NTP time: ${new Date(startNtpExecutionTime).toLocaleTimeString()}, local delay: ${initialDelay}ms`);
                        log(`Using NTP offset: ${ntpOffset}ms`);
                        
                        // Execute the synchronized BPM sequence
                        executeSyncBpmSequence(syncData, initialDelay);
                    } else {
                        log(`BPM sync sequence start time already passed (${Math.abs(initialDelay)}ms ago), skipping`);
                    }
                }
                
            } catch (error) {
                log('Error handling sync command: ' + error.message, 'error');
            }
        }
        
        // Execute synchronized BPM sequence received from MQTT
        function executeSyncBpmSequence(syncData, initialDelay) {
            const { command, bpm, division, beatCount, loop, intervalMs, startSyncPointUnixTime } = syncData;
            let currentBeat = 0;
            
            // If we're starting late, calculate which beat we should be on
            if (initialDelay < 0) {
                const elapsedMs = Math.abs(initialDelay);
                currentBeat = Math.floor(elapsedMs / intervalMs);
                if (currentBeat >= beatCount && !loop) {
                    log(`BPM sequence already completed, not joining`);
                    return;
                }
                if (loop) {
                    currentBeat = currentBeat % beatCount;
                }
                log(`Joining BPM sequence at beat ${currentBeat + 1} (${elapsedMs}ms late)`);
            }
            
            const executeBpmBeat = () => {
                if (currentBeat < beatCount || loop) {
                    // Calculate exact execution time for this beat using NTP-adjusted timing
                    const beatNtpExecutionTime = (startSyncPointUnixTime * 1000) + (currentBeat * intervalMs);
                    const beatLocalTime = beatNtpExecutionTime - ntpOffset;
                    const localDelay = beatLocalTime - Date.now();
                    
                    if (localDelay <= 0) {
                        // Execute immediately if we're at or past the target time
                        const actualExecutionTime = Date.now();
                        const actualNtpTime = actualExecutionTime + ntpOffset;
                        const syncAccuracy = Math.abs(actualNtpTime - beatNtpExecutionTime);
                        log(`Sync BPM beat ${currentBeat + 1} executed (NTP accuracy: ¬±${syncAccuracy}ms)`);
                        
                        executeCommand(command);
                        
                        currentBeat++;
                        if (loop && currentBeat >= beatCount) {
                            currentBeat = 0;
                        }
                        
                        if (currentBeat < beatCount || loop) {
                            setTimeout(executeBpmBeat, 0);
                        }
                    } else {
                        // Schedule execution at exact sync time
                        setTimeout(() => {
                            const actualExecutionTime = Date.now();
                            const actualNtpTime = actualExecutionTime + ntpOffset;
                            const syncAccuracy = Math.abs(actualNtpTime - beatNtpExecutionTime);
                            log(`Sync BPM beat ${currentBeat + 1} executed (NTP accuracy: ¬±${syncAccuracy}ms)`);
                            
                            executeCommand(command);
                            
                            currentBeat++;
                            if (loop && currentBeat >= beatCount) {
                                currentBeat = 0;
                            }
                            
                            if (currentBeat < beatCount || loop) {
                                setTimeout(executeBpmBeat, 0);
                            }
                        }, localDelay);
                    }
                }
            };
            
            // Start the sequence
            if (initialDelay > 0) {
                setTimeout(executeBpmBeat, initialDelay);
            } else {
                executeBpmBeat();
            }
        }

        function handleRhythmControl(message) {
            try {
                // Parse the rhythm control message
                // Expected formats:
                // "bpm:120" - Set BPM to 120
                // "division:8" - Set beat division to 8th notes
                // "bpm:120,division:4" - Set both BPM and division
                // JSON format: {"bpm": 120, "division": 4}
                
                let bpm = null;
                let division = null;
                
                // Try to parse as JSON first
                try {
                    const jsonData = JSON.parse(message);
                    if (jsonData.bpm !== undefined) bpm = parseFloat(jsonData.bpm);
                    if (jsonData.division !== undefined) division = parseInt(jsonData.division);
                } catch (e) {
                    // Parse as simple key:value format
                    const parts = message.split(',');
                    for (const part of parts) {
                        const [key, value] = part.trim().split(':');
                        if (key === 'bpm') {
                            bpm = parseFloat(value);
                        } else if (key === 'division') {
                            division = parseInt(value);
                        }
                    }
                }
                
                // Apply the changes
                let changes = [];
                let needsReschedule = false;
                
                if (bpm !== null && !isNaN(bpm) && bpm >= 30 && bpm <= 300) {
                    document.getElementById('bpmInput').value = bpm;
                    changes.push(`BPM: ${bpm}`);
                    needsReschedule = true;
                    log(`Rhythm control: BPM set to ${bpm}`);
                }
                
                if (division !== null && !isNaN(division) && [1, 2, 4, 8, 16, 32].includes(division)) {
                    document.getElementById('beatDivision').value = division;
                    changes.push(`Division: 1/${division}`);
                    needsReschedule = true;
                    log(`Rhythm control: Beat division set to 1/${division}`);
                }
                
                if (changes.length > 0) {
                    // Switch to BPM mode if not already
                    if (document.getElementById('schedulingMode').value !== 'bpm') {
                        document.getElementById('schedulingMode').value = 'bpm';
                        updateSchedulingMode();
                        log('Rhythm control: Switched to BPM scheduling mode');
                    }
                    
                    // Update timing display
                    updateBpmTiming();
                    
                    // Check if BPM scheduling is currently running and update it dynamically
                    if (needsReschedule && bpmInterval && currentSchedulingMode === 'bpm') {
                        updateRunningBpmSchedule();
                        log('Rhythm control: Updated running BPM schedule with new timing');
                    }
                    
                    // Show notification
                    showRhythmChangeNotification(changes.join(', '));
                    
                    log(`Rhythm control applied: ${changes.join(', ')}`);
                } else {
                    log('Rhythm control: Invalid message format. Use "bpm:120" or "division:4" or JSON format', 'warning');
                }
                
            } catch (error) {
                log('Rhythm control error: ' + error.message, 'error');
            }
        }

        function updateRunningBpmSchedule() {
            // Only update if BPM scheduling is currently active
            if (!bpmInterval || currentSchedulingMode !== 'bpm') {
                return;
            }
            
            // Get current command and settings
            const command = document.getElementById('commandInput').value.trim();
            const beatCount = parseInt(document.getElementById('beatCount').value);
            const loop = document.getElementById('bpmLoop').checked;
            
            if (!command) {
                return;
            }
            
            // Calculate time to wait until the nearest whole second
            const now = Date.now();
            const msUntilNextSecond = 1000 - (now % 1000);
            
            log(`Scheduling BPM update to occur at next whole second (${msUntilNextSecond}ms from now)`);
            
            // Update status to show pending update
            document.getElementById('commandStatus').textContent = `BPM scheduling active: updating at next second...`;
            
            // Wait until the nearest whole second to apply changes
            setTimeout(() => {
                // Clear the current interval
                clearTimeout(bpmInterval);
                bpmInterval = null;
                
                // Get new timing values
                const bpm = parseFloat(document.getElementById('bpmInput').value);
                const division = parseInt(document.getElementById('beatDivision').value);
                const intervalMs = (60000 / bpm) / (division / 4);
                
                log(`Applying BPM update at whole second: ${bpm} BPM, ${division} division, ${intervalMs.toFixed(1)}ms interval`);
                
                // Update status display
                document.getElementById('commandStatus').textContent = `BPM scheduling active: ${bpm} BPM (updated)`;
                
                // Continue with the current beat counter state
                // Note: We maintain the current execution counter and beat position
                let currentBeat = executionCounter % beatCount; // Estimate current position
                
                const executeBpmCommand = () => {
                    if (currentBeat < beatCount || loop) {
                        executeCommand(command);
                        executionCounter++;
                        document.getElementById('executionCount').textContent = executionCounter;
                        
                        currentBeat++;
                        if (loop && currentBeat >= beatCount) {
                            currentBeat = 0; // Reset for loop
                        }
                        
                        // Update next execution time with new interval and NTP offset
                        const nextNtpTime = Date.now() + ntpOffset + intervalMs;
                        const nextTime = new Date(nextNtpTime);
                        document.getElementById('nextExecution').textContent = nextTime.toLocaleTimeString() + ' (NTP)';
                        
                        if (currentBeat < beatCount || loop) {
                            bpmInterval = setTimeout(executeBpmCommand, intervalMs);
                        } else {
                            document.getElementById('commandStatus').className = 'status connected';
                            document.getElementById('commandStatus').textContent = 'BPM sequence completed';
                            document.getElementById('cancelBtn').disabled = true;
                        }
                    }
                };
                
                // Schedule next execution with new timing
                bpmInterval = setTimeout(executeBpmCommand, intervalMs);
                
            }, msUntilNextSecond);
        }

        function showRhythmChangeNotification(changes) {
            // Create a temporary notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 20px;
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
                z-index: 10000;
                font-weight: 600;
                animation: slideInLeft 0.3s ease-out;
            `;
            notification.innerHTML = `üéµ Rhythm Updated: ${changes}`;
            
            // Add slide-in animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideInLeft {
                    from { transform: translateX(-100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove notification after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideInLeft 0.3s ease-out reverse';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                    if (style.parentNode) {
                        document.head.removeChild(style);
                    }
                }, 300);
            }, 4000);
        }

        function subscribeToRhythmTopic() {
            if (!mqttClient || !mqttConnected) {
                return;
            }
            
            const rhythmTopic = 'trigger_rhythm';
            const qos = 1; // Use QoS 1 for reliable delivery
            
            mqttClient.subscribe(rhythmTopic, { qos: qos }, function (err) {
                if (err) {
                    log('Failed to subscribe to rhythm topic: ' + err.message, 'error');
                } else {
                    // Check if already in subscribed topics to avoid duplicates
                    const exists = subscribedTopics.some(sub => sub.topic === rhythmTopic);
                    if (!exists) {
                        subscribedTopics.push({ topic: rhythmTopic, qos: qos });
                    }
                    log('Auto-subscribed to rhythm control topic: ' + rhythmTopic + ' (QoS ' + qos + ')');
                    updateMqttSubscriptionStatus();
                }
            });
        }

        function displayMqttMessage(topic, message, type, timestamp) {
            const container = document.getElementById('mqttMessages');
            const entry = document.createElement('div');
            entry.style.marginBottom = '5px';
            entry.style.padding = '5px 10px';
            entry.style.borderRadius = '4px';
            entry.style.fontFamily = "'Consolas', 'Monaco', 'Courier New', monospace";
            entry.style.fontSize = '13px';
            entry.style.lineHeight = '1.3';

            // Use the already NTP-adjusted timestamp passed from the caller
            const timeStr = timestamp.toLocaleTimeString();
            
            if (type === 'RECEIVED') {
                entry.style.color = '#7ee787';
                entry.style.backgroundColor = 'rgba(126, 231, 135, 0.1)';
                entry.innerHTML = `<strong>[${timeStr}] üì• ${topic}:</strong> ${message}`;
            } else if (type === 'PUBLISHED') {
                entry.style.color = '#ff7b72';
                entry.style.backgroundColor = 'rgba(255, 123, 114, 0.1)';
                entry.innerHTML = `<strong>[${timeStr}] üì§ ${topic}:</strong> ${message}`;
            }

            container.appendChild(entry);

            // Store message for saving
            mqttMessages.push({
                timestamp: timestamp,
                topic: topic,
                message: message,
                type: type
            });

            // Limit messages to prevent memory issues
            const maxMessages = 1000;
            while (container.children.length > maxMessages) {
                container.removeChild(container.firstChild);
                mqttMessages.shift();
            }

            // Auto-scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function clearMqttMessages() {
            document.getElementById('mqttMessages').innerHTML =
                '<div style="color: #7d8590; font-style: italic;">üì° MQTT messages will appear here...</div>';
            mqttMessages = [];
            log('MQTT messages cleared');
        }

        function saveMqttLog() {
            if (mqttMessages.length === 0) {
                alert('No MQTT messages to save');
                return;
            }

            const logContent = mqttMessages.map(msg => {
                const timeStr = msg.timestamp.toLocaleString();
                const typeStr = msg.type === 'RECEIVED' ? 'üì•' : 'üì§';
                return `[${timeStr}] ${typeStr} ${msg.topic}: ${msg.message}`;
            }).join('\n');

            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mqtt_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log('MQTT log saved (' + mqttMessages.length + ' messages)');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            if (syncInterval) clearInterval(syncInterval);
            if (dataRateInterval) clearInterval(dataRateInterval);
            if (connectionHealthInterval) clearInterval(connectionHealthInterval);
            if (phantomTimeDisplayInterval) clearInterval(phantomTimeDisplayInterval);
            if (bpmInterval) clearTimeout(bpmInterval);
            if (fpsInterval) clearTimeout(fpsInterval);
            if (metronomeInterval) clearTimeout(metronomeInterval);
            if (mqttClient) {
                mqttClient.end();
            }
            await disconnectSerial();
        });
    </script>
</body>
</html> 